<!DOCTYPE html>
<!-- https://threejs.org/examples/webgl_animation_keyframes.html -->
<html>
  <head>
    <title>Littlest Tokyo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="manifest" href="manifest.json">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
      body {
        background-color: #bfe3dd;
        color: #000;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script type="module">
      import * as THREE from './three.module.js';
      import { OrbitControls } from './OrbitControls.js';
      import { GLTFLoader } from './GLTFLoader.js';
      import { DRACOLoader } from './DRACOLoader.js';
      let mixer;
      const clock = new THREE.Clock();
      const container = document.getElementById( 'container' );
      const renderer = new THREE.WebGLRenderer( { antialias: true } );
      renderer.setPixelRatio( window.devicePixelRatio );
      renderer.setSize( window.innerWidth, window.innerHeight );
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.shadowMap.enabled = true;
      container.appendChild( renderer.domElement );
      const scene = new THREE.Scene();
      scene.background = new THREE.Color( 0xbfe3dd );
      
      // Raycaster setup for hover effects
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let hoveredObject = null;
      let nft1Undercover = null;
      const originalScale = new THREE.Vector3(1, 1, 1);
      const originalPosition = new THREE.Vector3();
      const hoverScale = 1.03; // Reduced scale effect (3% increase)
      const forwardOffset = 0.1; // How much to move forward
      const lerpFactor = 0.15; // Slightly faster transition
      
      // Mouse move handler
      function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }
      
      // Touch move handler
      function onTouchMove(event) {
        if (event.touches.length > 0) {
          mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
        }
      }
      
      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('touchmove', onTouchMove);
      
      // Camera setup
      const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
      camera.position.set( 10, 10, 10 );
      
      // Controls setup
      const controls = new OrbitControls( camera, renderer.domElement );
      controls.target.set( 0, 0, 0 );
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enablePan = false;
      controls.mouseButtons.RIGHT = null;
      controls.mouseButtons.MIDDLE = null; // opzionale: disabilita anche la rotella
      controls.update();
      
      // Lighting setup
      const ambientLight = new THREE.AmbientLight( 0xffffff, 0.5 );
      scene.add( ambientLight );
      
      const dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
      dirLight.position.set( 10, 10, 10 );
      dirLight.castShadow = true;
      scene.add( dirLight );
      
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath( './' );
      const loader = new GLTFLoader();
      loader.setDRACOLoader( dracoLoader );
      
      // Add loading manager
      const loadingManager = new THREE.LoadingManager();
      loadingManager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
        console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
      };
      loadingManager.onError = function ( url ) {
        console.log( 'There was an error loading ' + url );
      };
      loader.manager = loadingManager;
      
      let modelBox, modelCenter, modelSize, modelMaxDim, modelDistance;
      
      loader.load( 'kaizen-era-shop-nft1.glb', function ( gltf ) {
        const model = gltf.scene;
        
        // Find NFT1Undercover object
        model.traverse((child) => {
          if (child.name === 'NFT1Undercover') {
            nft1Undercover = child;
            originalScale.copy(child.scale);
            originalPosition.copy(child.position);
          }
        });
        
        // Center the model
        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        model.position.sub(center);
        
        // Scale the model appropriately
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 5 / maxDim;
        model.scale.multiplyScalar(scale);
        
        scene.add( model );
        
        // Salva info per responsività
        modelBox = box;
        modelCenter = center;
        modelSize = size;
        modelMaxDim = maxDim;
        
        // --- CAMERA FRONT VIEW OPTIMIZED & RESPONSIVE ---
        setCameraAndZoom();
        
        if (gltf.animations && gltf.animations.length > 0) {
          mixer = new THREE.AnimationMixer( model );
          mixer.clipAction( gltf.animations[ 0 ] ).play();
        }
        
        // --- CAMERA FRONT VIEW OPTIMIZED ---
        // Calcolo la dimensione massima per vedere tutto il modello
        const distance = maxDim * 2.5 / Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
        camera.position.set(center.x, center.y, center.z + distance);
        // Calcolo la base del modello (minY della bounding box)
        controls.target.set(center.x, center.y, center.z);
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI / 2;
        // Imposta i limiti di zoom
        // Puoi modificare questi valori per le tue preferenze:
        // minDistance: più piccolo = più vicino al modello
        // maxDistance: più grande = più lontano dal modello
        const minZoom = distance * 0.835; // Modifica 0.5 per avvicinare di più o meno
        const maxZoom = distance * 1.1; // Modifica 1.5 per allontanare di più o meno
        controls.minDistance = minZoom;
        controls.maxDistance = maxZoom;
        controls.update();
        
        animate();
      }, 
      // Progress callback
      function ( xhr ) {
        console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
      },
      // Error callback
      function ( error ) {
        console.error( 'An error happened loading the model:', error );
      } );
      
      function animate() {
        requestAnimationFrame( animate );
        const delta = clock.getDelta();
        if (mixer) mixer.update( delta );
        
        // Update raycaster
        raycaster.setFromCamera(mouse, camera);
        
        // Check for intersections with NFT1Undercover
        if (nft1Undercover) {
          const intersects = raycaster.intersectObject(nft1Undercover, true);
          
          if (intersects.length > 0) {
            if (hoveredObject !== nft1Undercover) {
              hoveredObject = nft1Undercover;
            }
            
            // Get camera direction and invert it to move towards camera
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            cameraDirection.negate(); // Invert the direction
            
            // Calculate forward position
            const forwardPosition = new THREE.Vector3();
            forwardPosition.copy(originalPosition).add(cameraDirection.multiplyScalar(forwardOffset));
            
            // Smoothly scale up and move forward
            nft1Undercover.scale.lerp(
              new THREE.Vector3(
                originalScale.x * hoverScale,
                originalScale.y * hoverScale,
                originalScale.z * hoverScale
              ),
              lerpFactor
            );
            
            // Smoothly move forward
            nft1Undercover.position.lerp(forwardPosition, lerpFactor);
          } else {
            if (hoveredObject === nft1Undercover) {
              hoveredObject = null;
            }
            // Smoothly return to original scale and position
            nft1Undercover.scale.lerp(originalScale, lerpFactor);
            nft1Undercover.position.lerp(originalPosition, lerpFactor);
          }
        }
        
        controls.update();
        renderer.render( scene, camera );
      }
      
      // Funzione per calcolare la distanza minima sicura per vedere tutto il modello anche ruotando
      function getSafeMinDistance(box, camera) {
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const diagonal = size.length() / 2;
        const margin = 2; // 15% di margine
        const fov = camera.fov * (Math.PI / 180);
        const aspect = camera.aspect;
        const fitHeightDistance = (diagonal * margin) / Math.sin(fov / 2);
        const fitWidthDistance = (diagonal * margin) / Math.sin(Math.atan(Math.tan(fov / 2) * aspect));
        return Math.max(fitHeightDistance, fitWidthDistance);
      }
      
      // Funzione per impostare camera e limiti zoom in modo responsive
      function setCameraAndZoom() {
        if (!modelBox) return;
        // Calcola sempre il centro attuale della bounding box
        const center = modelBox.getCenter(new THREE.Vector3());
        modelCenter = center;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        // Usa la distanza minima sicura
        const minDistance = getSafeMinDistance(modelBox, camera);
        controls.minDistance = minDistance;
        controls.maxDistance = minDistance * 2;
        controls.target.set(center.x, center.y, center.z);
        controls.update();
        modelDistance = minDistance;
        // Mantieni la camera sempre centrata rispetto al modello
        // (mantieni la distanza attuale se già > minDistance, altrimenti riposiziona)
        const camDir = new THREE.Vector3();
        camera.getWorldDirection(camDir);
        camDir.normalize();
        // Posiziona la camera lungo l'asse Z positiva rispetto al centro
        camera.position.set(center.x, center.y, center.z + minDistance * 1.05);
      }
      
      // Aggiorna tutto su resize
      window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        setCameraAndZoom();
      });
    </script>
  </body>
</html>
