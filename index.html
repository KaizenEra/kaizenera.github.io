<!DOCTYPE html>
<!-- https://threejs.org/examples/webgl_animation_keyframes.html -->
<html>
  <head>
    <title>Littlest Tokyo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="manifest" href="manifest.json">
    <link type="text/css" rel="stylesheet" href="main.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
      body {
        background-color: #bfe3dd;
        color: #000;
      }
      #info-panel {
        font-family: Arial, sans-serif;
        color: #333;
      }
      #info-panel h2 {
        margin-top: 0;
        color: #2c3e50;
      }
      #info-panel ul {
        padding-left: 20px;
      }
      #info-panel li {
        margin: 5px 0;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script type="module">
      import * as THREE from './three.module.js';
      import { OrbitControls } from './OrbitControls.js';
      import { GLTFLoader } from './GLTFLoader.js';
      import { DRACOLoader } from './DRACOLoader.js';
      let mixer;
      const clock = new THREE.Clock();
      const container = document.getElementById( 'container' );
      const renderer = new THREE.WebGLRenderer( { antialias: true } );
      renderer.setPixelRatio( window.devicePixelRatio );
      renderer.setSize( window.innerWidth, window.innerHeight );
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.shadowMap.enabled = true;
      container.appendChild( renderer.domElement );
      const scene = new THREE.Scene();
      scene.background = new THREE.Color( 0xbfe3dd );
      
      // Raycaster setup for hover effects
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let hoveredObject = null;
      let nft1Undercover = null;
      const originalScale = new THREE.Vector3(1, 1, 1);
      const originalPosition = new THREE.Vector3();
      const hoverScale = 1.03; // Reduced scale effect (3% increase)
      const forwardOffset = 0.1; // How much to move forward
      const lerpFactor = 0.15; // Slightly faster transition
      
      // Camera setup
      const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
      camera.position.set( 10, 10, 10 );
      
      // Controls setup
      const controls = new OrbitControls( camera, renderer.domElement );
      controls.target.set( 0, 0, 0 );
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enablePan = false;
      controls.mouseButtons.RIGHT = null;
      controls.mouseButtons.MIDDLE = null;
      controls.update();
      
      let isZoomed = false;
      let originalCameraPosition = new THREE.Vector3();
      let originalControlsTarget = new THREE.Vector3();
      let infoPanel = null;
      
      // Mouse move handler
      function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }
      
      // Touch move handler
      function onTouchMove(event) {
        if (event.touches.length > 0) {
          mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
        }
      }
      
      // Click handler
      function onClick(event) {
        if (nft1Undercover && raycaster.intersectObject(nft1Undercover, true).length > 0) {
          if (!isZoomed) {
            // Salva la posizione originale
            originalCameraPosition.copy(camera.position);
            originalControlsTarget.copy(controls.target);
            
            // Calcola la posizione per la vista dettagliata
            const targetPosition = nft1Undercover.position.clone();
            const zoomDistance = 2;
            
            // Anima la camera
            gsap.to(camera.position, {
              x: targetPosition.x,
              y: targetPosition.y,
              z: targetPosition.z + zoomDistance,
              duration: 1,
              ease: "power2.inOut",
              onComplete: () => {
                // Blocca lo zoom out nella vista dettagliata
                controls.minDistance = zoomDistance;
                controls.maxDistance = zoomDistance;
                // Disabilita completamente i controlli orbitali
                controls.enabled = false;
                controls.update();
              }
            });
            
            gsap.to(controls.target, {
              x: targetPosition.x,
              y: targetPosition.y,
              z: targetPosition.z,
              duration: 1,
              ease: "power2.inOut"
            });
            
            // Mostra il pannello info
            showInfoPanel();
            
            isZoomed = true;
          }
        }
      }
      
      // Funzione per mostrare il pannello info
      function showInfoPanel() {
        if (!infoPanel) {
          infoPanel = document.createElement('div');
          infoPanel.id = 'info-panel';
          infoPanel.style.position = 'fixed';
          infoPanel.style.right = '20px';
          infoPanel.style.top = '20px';
          infoPanel.style.width = '300px';
          infoPanel.style.padding = '20px';
          infoPanel.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
          infoPanel.style.borderRadius = '10px';
          infoPanel.style.boxShadow = '0 0 10px rgba(0,0,0,0.2)';
          infoPanel.style.transform = 'translateX(100%)';
          infoPanel.style.transition = 'transform 0.5s ease';
          
          // Aggiungi il contenuto del pannello
          infoPanel.innerHTML = `
            <h2>NFT Undercover</h2>
            <p>Questo è un NFT unico nel suo genere...</p>
            <p>Caratteristiche:</p>
            <ul>
              <li>Caratteristica 1</li>
              <li>Caratteristica 2</li>
              <li>Caratteristica 3</li>
            </ul>
            <button id="back-to-main" style="
              margin-top: 15px;
              padding: 8px 16px;
              background-color: #2c3e50;
              color: white;
              border: none;
              border-radius: 5px;
              cursor: pointer;
              transition: background-color 0.3s;
            ">Torna alla vista principale</button>
          `;
          
          document.body.appendChild(infoPanel);
          
          // Aggiungi event listener per il pulsante
          document.getElementById('back-to-main').addEventListener('click', () => {
            if (isZoomed) {
              // Ripristina i limiti di zoom originali
              const minDistance = getSafeMinDistance(modelBox, camera);
              controls.minDistance = 0;
              controls.maxDistance = minDistance * 1.5;
              
              // Riabilita i controlli orbitali
              controls.enabled = true;
              
              // Anima il ritorno alla posizione originale
              gsap.to(camera.position, {
                x: originalCameraPosition.x,
                y: originalCameraPosition.y,
                z: originalCameraPosition.z,
                duration: 1,
                ease: "power2.inOut"
              });
              
              gsap.to(controls.target, {
                x: originalControlsTarget.x,
                y: originalControlsTarget.y,
                z: originalControlsTarget.z,
                duration: 1,
                ease: "power2.inOut"
              });
              
              // Nascondi il pannello info
              hideInfoPanel();
              
              isZoomed = false;
            }
          });
        }
        
        // Mostra il pannello con animazione
        setTimeout(() => {
          infoPanel.style.transform = 'translateX(0)';
        }, 100);
      }
      
      // Funzione per nascondere il pannello info
      function hideInfoPanel() {
        if (infoPanel) {
          infoPanel.style.transform = 'translateX(100%)';
        }
      }
      
      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('touchmove', onTouchMove);
      window.addEventListener('click', onClick);
      
      // Lighting setup
      const ambientLight = new THREE.AmbientLight( 0xffffff, 0.5 );
      scene.add( ambientLight );
      
      const dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
      dirLight.position.set( 10, 10, 10 );
      dirLight.castShadow = true;
      scene.add( dirLight );
      
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath( './' );
      const loader = new GLTFLoader();
      loader.setDRACOLoader( dracoLoader );
      
      // Add loading manager
      const loadingManager = new THREE.LoadingManager();
      loadingManager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
        console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
      };
      loadingManager.onError = function ( url ) {
        console.log( 'There was an error loading ' + url );
      };
      loader.manager = loadingManager;
      
      let modelBox, modelCenter, modelSize, modelMaxDim, modelDistance;
      
      loader.load( 'kaizen-era-shop-nft123.glb', function ( gltf ) {
        const model = gltf.scene;
        
        // Find NFT1Undercover object
        model.traverse((child) => {
          if (child.name === 'NFT1Undercover') {
            nft1Undercover = child;
            originalScale.copy(child.scale);
            originalPosition.copy(child.position);
          }
        });
        
        // Center the model
        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        model.position.sub(center);
        
        // Scale the model appropriately
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 5 / maxDim;
        model.scale.multiplyScalar(scale);
        
        scene.add( model );
        
        // Salva info per responsività
        modelBox = box;
        modelCenter = center;
        modelSize = size;
        modelMaxDim = maxDim;
        
        // --- CAMERA FRONT VIEW OPTIMIZED & RESPONSIVE ---
        setCameraAndZoom();
        
        if (gltf.animations && gltf.animations.length > 0) {
          mixer = new THREE.AnimationMixer( model );
          mixer.clipAction( gltf.animations[ 0 ] ).play();
        }
        
        // --- CAMERA FRONT VIEW OPTIMIZED ---
        // Calcolo la dimensione massima per vedere tutto il modello
        const distance = maxDim * 2.7 / Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
        camera.position.set(center.x, center.y, center.z + distance);
        // Calcolo la base del modello (minY della bounding box)
        controls.target.set(center.x, center.y, center.z);
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI / 2;
        
        // Imposta i limiti di zoom iniziali
        const minDistance = getSafeMinDistance(box, camera);
        controls.minDistance = 0;
        controls.maxDistance = minDistance * 1.5;
        controls.update();
        
        animate();
      }, 
      // Progress callback
      function ( xhr ) {
        console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
      },
      // Error callback
      function ( error ) {
        console.error( 'An error happened loading the model:', error );
      } );
      
      function animate() {
        requestAnimationFrame( animate );
        const delta = clock.getDelta();
        if (mixer) mixer.update( delta );
        
        // Update raycaster
        raycaster.setFromCamera(mouse, camera);
        
        // Check for intersections with NFT1Undercover
        if (nft1Undercover) {
          const intersects = raycaster.intersectObject(nft1Undercover, true);
          
          if (intersects.length > 0) {
            if (hoveredObject !== nft1Undercover) {
              hoveredObject = nft1Undercover;
            }
            
            // Get camera direction and invert it to move towards camera
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            cameraDirection.negate();
            
            // Calculate forward position
            const forwardPosition = new THREE.Vector3();
            forwardPosition.copy(originalPosition).add(cameraDirection.multiplyScalar(forwardOffset));
            
            // Smoothly scale up and move forward
            nft1Undercover.scale.lerp(
              new THREE.Vector3(
                originalScale.x * hoverScale,
                originalScale.y * hoverScale,
                originalScale.z * hoverScale
              ),
              lerpFactor
            );
            
            // Smoothly move forward
            nft1Undercover.position.lerp(forwardPosition, lerpFactor);
          } else {
            if (hoveredObject === nft1Undercover) {
              hoveredObject = null;
            }
            // Smoothly return to original scale and position
            nft1Undercover.scale.lerp(originalScale, lerpFactor);
            nft1Undercover.position.lerp(originalPosition, lerpFactor);
          }
        }
        
        controls.update();
        renderer.render( scene, camera );
      }
      
      // Funzione per calcolare la distanza minima sicura per vedere tutto il modello anche ruotando
      function getSafeMinDistance(box, camera) {
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const diagonal = size.length() / 2;
        const margin = 2; // 15% di margine
        const fov = camera.fov * (Math.PI / 180);
        const aspect = camera.aspect;
        const fitHeightDistance = (diagonal * margin) / Math.sin(fov / 2);
        const fitWidthDistance = (diagonal * margin) / Math.sin(Math.atan(Math.tan(fov / 2) * aspect));
        return Math.max(fitHeightDistance, fitWidthDistance);
      }
      
      // Funzione per impostare camera e limiti zoom in modo responsive
      function setCameraAndZoom() {
        if (!modelBox) return;
        const center = modelBox.getCenter(new THREE.Vector3());
        modelCenter = center;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        const minDistance = getSafeMinDistance(modelBox, camera);
        // Imposta solo il limite di zoom out
        controls.minDistance = 0;
        controls.maxDistance = minDistance * 3; // Limite solo per lo zoom out
        controls.target.set(center.x, center.y, center.z);
        controls.update();
        modelDistance = minDistance;
        const camDir = new THREE.Vector3();
        camera.getWorldDirection(camDir);
        camDir.normalize();
        camera.position.set(center.x, center.y, center.z + minDistance * 1.05);
      }
      
      // Aggiorna tutto su resize
      window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        setCameraAndZoom();
      });
    </script>
  </body>
</html>
